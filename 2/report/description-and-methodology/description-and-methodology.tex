
This section describes the sound program, and details how it was developed. This section covers procedure, setup and configuration, tools and program details.

need to include a bit about the Makefile here


\section{Functional description}

The solution program plays sound effects and music, and is controlled by the eight buttons on the STK1000.
The LEDs are used to indicate which sound is playing.

When the program is started, the board is in idle mode, ready to react to button presses.
Pressing any of the buttons SW0-SW3 plays a piece of music, which loops until another sound is selected.
Pressing any of the buttons SW4-SW6 plays a sound effect, which is not looped.
Pressing SW7 stops all playback.

\subsection{Sound effects}

The sound effects are generatively composed by wrapping a generator signal in a configurable ADSR volume envelope.
TODO: talk about ADSR.
The available generator signals in the program are NOISE, SAWTOOTH and SQUARE.

TODO: talk about NISE, SAWTOOTH and SQUARE, with photos.

\subsubsection{Explosion}

'Explosion' is a NOISE-based sound effect with the following ADSR envelope:
Attack: 0 ms
Decay:  1000 ms
Sustain: 0\%
Release: 0 ms
The effect is held for 0 ms.

Total length: 0 ms + 1000 ms + 0 ms + 0 ms = 1000 ms
'Explosion' can be triggered by pressing SW6.
TODO: add photo

\subsubsection{Air horn}
'Air horn' is a SAWTOOTH-based sound effect with the following ADSR envelope:
Attack: 100 ms
Decay:  100 ms
Sustain: 70\%
Release: 500 ms
The effect is held for 0 ms.

Total length: 100 ms + 100 ms + 500 ms + 0 ms = 700 ms
'Air horn' can be triggered by pressing SW5.
TODO: add photo

\subsubsection{Teleport}
'Teleport' is a SQUARE-based sound effect with the following ADSR envelope:
Attack: 500 ms
Decay:  1250 ms
Sustain: 20\%
Release: 250 ms
The effect is held for 0 ms.

Length: 500 ms + 1250 ms + 250 ms + 0 ms = 2000 ms
'Teleport' can be triggered by pressing SW4.
TODO: add photo


\subsection{Music}

The music pieces in the solution program are played by the MOD player.

\subsubsection{Tuulenvire by Dizzy/CNCD}
Tuulenvire is a 2:09 long 808KB composition in the ambient genre, featuring piano and accordion, amongst other instruments.
This composition was chosen to demonstrate how careful composing can render realistic compositions with a relatively small memory footprint.
It uses 25 different PCM-coded sounds.
Tuulenvire can be triggered by pressing SW3.

\subsubsection{Boesendorfer P. S. S. by Romeo Knight}
Boesendorfer P. S. S. is a 3:22 long 211KB solo piano composition, chosen to illustrate the possibilities enabled by a hybrid generative/recorded approach.
It uses 9 different PCM-coded sounds.
Boesendorfer P. S. S. can be triggered by pressing SW2.

\subsubsection{Drop The Panic by H0ffmann}
Drop The Panic is a 4:05 long 702KB ``glitch-hop'' composition.
It was chosen to show how MOD files can support embedded vocals.
It uses 31 different PCM-coded sounds.
The composition was tweaked by adding some extra inaudible notes in the beginning of the song to decrease critical cache misses by the MOD player during playback on the STK1000.
Drop The Panic can be triggered by pressing SW1.

\subsubsection{Bacongrytor by Maktone}
Bacongrytor is a 15Kb endless loop chiptune-style composition, chosen to demonstrate the compactness of the MOD format, and therefore its aptfulness for use on microcontrollers.
It uses 7 different PCM-coded sounds.
Bacongrytor can be triggered by pressing SW0.


\section{Solution components}

The solution consists of three separate components. This section describes each of the three.

\subsection{main program}
\subsection{synth}

\subsection{libmodam}

Libmodam is the name of the MOD file parser and player written for this assignment.
It is written as a portable, cross-platform C library.
It has been tested on avr32 and on x86.

Libmodam is statically linked in the main solution program.

Libmodam includes a python utility script for platforms without filesystems.
Normally, to use libmodam, a programmer must read a MOD file to to a byte buffer, and pass the buffer to libmodam, as it is done in the sample usage program test.c.
This is sadly impossible in environments without a file system.
The python script solves this by reading arbitrary files and converting them to C-code declaring large static const char* arrays representing those files.
For most platforms, this means that the files will be bundled with the executable in the .text section, making them read only.

By the programmer using libmodam, two main functions must be called repeatedly to generate output.
One of these functions is \texttt{MOD\_Player\_play(...)}.
This function returns a single sample of output, and must be called \texttt{sample rate} times per second for real time playback.
The other function is \texttt{MOD\_Player\_step(...)}, and advances logical state, such as which notes should be playing and what effect should be applied.
This function should be called no less that 50 times per second for real time playback.

These two driving functions are split up like this to minimize and constantivize the time spent generating the next output sample, to make libmodam more real-time-friendly.

Libmodam implements support for \texttt{M.K.} type MODs.
A subset of the playback effects from \texttt{M.K.} have been implemented.
Which effects to implement was chosen so that the most popular and often used effects were prioritized.
A list of the effects in \texttt{M.K.}, and their implementation status in libmodam can be found in table XXX.


\section{Experimental Procedure}


\section{Configuration}

We can reference our previous report here, so that we don't have to write so much.

\subsection{Jumpers}

As before.

\subsection{GPIO connections}

As before, + maybe mention audio.

\subsection{Audio}

Jack etc

\section{Development of the program}



\subsection{Sound effect synth}

\subsection{Libmodam}

Libmodam was initially developed in a linux environment on an x86 PC, and later ported to avr32 and the STK1000.
This was done for comfort reasons: there was no need to be in the lab to develop; testing and iterating went a lot faster when code and data didn't need to be uploaded after each modification; and there was no need to focus on performance until features were confirmed to be working properly.
As an added bonus, this also ensured a certain degree of portability, which is a nice property for a library to have.
The python file conversion tool was developed alongside libmodam.

When the code was run on the STK1000 for the first time, the performance difference between the Intel i7 multi-GHz linux laptop and the STK1000 became immediately apparent.
The sound produced by libmodam on the STK1000 at this point did not even remotely sound like music.
In fact, it was more akin to a bowl of half-eaten oatmeal porridge left overnight, were porridge as audibly dull as it is bland in taste.
One of the main reasons for the abysmal performance on the STK1000 was the lack of a floating point unit in the AP7000.
Libmodam used floating point numbers heavily.
The library was rewritten to use integer arithmetic, which helped immensely.
Further optimizations were iteratively applied after this, until the code reached a point of acceptable performance.

\subsection{The main program}

How we assembled everything in the main program.

\subsubsection{Setting up the LEDs}
\subsubsection{Setting up the buttons}
\subsubsection{Setting up the audio}
rant about sample rates, div, diven


list of what we did:

* Board was set up w/ jumpers and such
* Leds and buttons were hooked up in hardware
* Leds and buttons were hooked up in software
* Code was split into separate files
* Audio was hooked up with apropriate settings
* Sound was tested to work using random noise


the following two groups of bullet points happened in parallel:

* a C sound effect synth inspired by sfxr was prototyped on a PC
* the synth was ported to avr32
* the synth was developed further on the avr32
* the synth was used in the stk1000 program to play various sound effects

* a C MOD player library + python tools inspired by amiga trackers were developed on a PC
* the library was tested on the avr32 and needed a great deal of optimization
* a great deal of optimization occurred 
* the library was used in the stk1000 program to play selected mods


finally:

* the actual main program flow was decided upon and written, hooking button and led behaviour together with sound effects and music





\section{Programming environment}

\subsection{JTAGICE}
We can reference our previous report here, so that we don't have to write so much.

\subsection{GNU Debugger}
since last time:
* discovered tui mode: looks nice, breaks the makefile
* avr32gdbproxy -f0.8Mb -a 0.0.0.0:1024 and target extended-remote:1024

\subsection{Make}
we can reference.

\subsection{Other tools}

\begin{itemize}
\item OpenMPT, a MOD tracker, was used to examine MOD files during the development of libmodam.
\item \texttt{vim} was employed as the authors' text editor of choice.
\item \texttt{git} was used for version control.
\item The project was hosted in a private GitHub repository.
\item The report was written with \LaTeX.
\item AVR32-specific flavors of GNU's \texttt{as} and \texttt{ld} were used to assemble and link executables.
\item \texttt{avr32program} was used to program the STK1000 with the JTAGICE.
\end{itemize}

table XXX:
\begin{table}
        \begin{tabular}{|l|l|}

        \hline
        Effect & Implemented? \\
        \hline
        \hline
        Arpeggio & implemented \\
        \hline
        Slide up & implemented \\
        \hline
        Slide down & implemented \\
        \hline
        Slide to note & implemented \\
        \hline
        Vibrato & was implemented at one point, but was later removed for performance reasons \\
        \hline
        Continue slide to note and volume slide & implemented \\
        \hline
        Tremolo & not implemented \\
        \hline
        Unused & implemented \\
        \hline
        Set sample offset & not implemented \\
        \hline
        Volume slide & implemented \\
        \hline
        Position jump & implemented \\
        \hline
        Set volume & implemented \\
        \hline
        Pattern break & implemented \\
        \hline
        Set filter on/off & not implemented \\
        \hline
        Fineslide up & not implemented \\
        \hline
        Fineslide down & not implemented \\
        \hline
        Set glissando on/off & not implemented \\
        \hline
        Set vibrato waveform & not implemented \\
        \hline
        Set finetune value & not implemented \\
        \hline
        Loop pattern & implemented \\
        \hline
        Set tremolo waveform & not implemented \\
        \hline
        Extended unused & implemented \\
        \hline
        Retrigger sample & not implemented \\
        \hline
        Fine volume slide up & implemented \\
        \hline
        Fine volume slide down & implemented \\
        \hline
        Cut sample & implemented \\
        \hline
        Delay sample & not implemented \\
        \hline
        Delay pattern & not implemented \\
        \hline
        Invert loop & not implemented \\
        \hline
        Set speed & implemented \\
        \hline
        \end{tabular}
\end{table}

For more details about what these effects do, refer to XXX.
