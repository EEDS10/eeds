
\subsection{Sound effect synth}

The core of every synthesizer is the oscillator generating signals, so it was essential to develop first in order to produce sound signals to play.
Sawtooth and square waves were chosen as they are relatively easy to implement.
A noise signal was added as it required no extra logic, and it is needed to make the explosion sound.

After the oscillator was capable of producing waves with arbitrary frequencies, development began on the ADSR envelope.
Code for the sustain part of the sound was the easiest to write, as it just required the amplitude to be scaled down so that the highest possible amplitude was a given fraction of the highest possible amplitude.
Scaling for the attack, decay and release part was a bit worse however, as floating point divisions should be avoided at all costs.
In the end an acceptable result was reached with a smart ordering of integer multiplications and divisions.

\subsection{Libmodam}

Libmodam was initially developed in a linux environment on an x86 PC, and later ported to avr32 and the STK1000.
This was done for comfort reasons: there was no need to be in the lab to develop; testing and iterating went a lot faster when code and data didn't need to be uploaded after each modification; and there was no need to focus on performance until features were confirmed to be working properly.
As an added bonus, this also ensured a certain degree of portability, which is a nice property for a library to have.
The python file conversion tool was developed alongside libmodam.

When the code was run on the STK1000 for the first time, the performance difference between the Intel i7 multi-GHz linux laptop and the STK1000 became immediately apparent.
The sound produced by libmodam on the STK1000 at this point did not even remotely sound like music.
In fact, it was more akin to a bowl of half-eaten oatmeal porridge left overnight, were porridge as audibly dull as it is bland in taste.
One of the main reasons for the abysmal performance on the STK1000 was the lack of a floating point unit in the AP7000.
Libmodam used floating point numbers heavily.
The library was rewritten to use integer arithmetic, which helped immensely.
Further optimizations were iteratively applied after this, until the code reached a point of acceptable performance.

\subsection{The main program}

The main programmed was developed in the lab, room XXX, 4th floor ITV-building, NTNU.
First, the board was configured as in the configuration section of this report.
Then, LEDs and and buttons were hooked up in the program, as detailed in their respective sections of this report.
After this, code was refactored and split into several files, and the ABDAC was hooked up in the program, as detailed in the setting up the audio section.

Once the ABDAC was hooked up, random noise was sent to the ABDAC output register, to see if everything was set up correctly.

At this point, development of libmodam and the synth started. This is detailed in other sections of this report. Once they were finished, they were integrated into the main program.
Some wrapper logic, as well as user interface code was hooked up, and hey presto, the program was done.


\subsubsection{Setting up the LEDs}
	On initialization, the address of the \texttt{PIO} which the LEDs are connected to is stored as a pointer.
	A bitfield, represented as an integer, is used to indicate which LEDs to enable.
	This value is written to the \texttt{PER} and \texttt{OER} registers of the \texttt{PIO} to enable the indicated LEDs.
	In C, the syntax for this is \texttt{pio->reg = bits}, where \texttt{pio} is a pointer to an \texttt{avr32_pio_t} struct containing the address of the appropriate \texttt{PIO}.

	For a more detailed explanation of how the LEDs on the STK1000 are set up, see page 4 of \cite{tdt4258-1}.

	LEDs can then be enabled or disabled by writing appropriate values to the PIO's \texttt{SODR} and \texttt{CODR} registers, respectively.
	
\subsubsection{Setting up the buttons}

The button setup for this assignment is almost exactly the same as the setup from assignment 1\cite{tdt4258-1}.
The only difference is that the setup code is written in C, rather than assembly, which allows for higher lever abstractions.
The button code leverages the inversion of control principle, with dependency injection through the argument list of the setup function.

\subsubsection{Setting up the audio}

The audio setup code is organized in the same way as the LED and button setup code -- an injectable setup function in a separate file.
The internal DAC, which is used for audio output, uses pin 20 and 21 of PIOB as output pins.
These pins must be disabled so that the ABDAC can attain full control of them.

In order to drive the ABDAC, a clock must be set up.
Generic clock 6 is the clock that powers the ABDAC.
The generic clock 6 is in the assignment set up to be driven by oscillator 1, which runs at 12Mhz.
Because the clock fires an ABDAC interrupt for every 256th clock tick, this means that the sample rate will be 46875.
This is a little high.
Luckily, the clock speed can be divided using the divide feature.
By enabling the divide feature, and setting the \texttt{div} to 0, the clock signal is divided by two.
This is because the clock speed is divided by $2\times($\texttt{div}$+1)$.

