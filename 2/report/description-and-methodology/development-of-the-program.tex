
\subsection{Sound effect synth}

The core of every synthesizer is the oscillator generating signals, so it was essential to develop first in order to produce sound signals to play.
Sawtooth and square waves were chosen as they are relatively easy to implement.
A noise signal was added as it required no extra logic, and it is needed to make the explosion sound.

After the oscillator was capable of producing waves with arbitrary frequencies, development began on the ADSR envelope.
Code for the sustain part of the sound was the easiest to write, as it just required the amplitude to be scaled down so that the highest possible amplitude was a given fraction of the highest possible amplitude.
Scaling for the attack, decay and release part was a bit worse however, as floating point divisions should be avoided at all costs.
In the end an acceptable result was reached with a smart ordering of integer multiplications and divisions.

\subsection{Libmodam}

Libmodam was initially developed in a linux environment on an x86 PC, and later ported to avr32 and the STK1000.
This was done for comfort reasons: there was no need to be in the lab to develop; testing and iterating went a lot faster when code and data didn't need to be uploaded after each modification; and there was no need to focus on performance until features were confirmed to be working properly.
As an added bonus, this also ensured a certain degree of portability, which is a nice property for a library to have.
The python file conversion tool was developed alongside libmodam.

When the code was run on the STK1000 for the first time, the performance difference between the Intel i7 multi-GHz linux laptop and the STK1000 became immediately apparent.
The sound produced by libmodam on the STK1000 at this point did not even remotely sound like music.
In fact, it was more akin to a bowl of half-eaten oatmeal porridge left overnight, were porridge as audibly dull as it is bland in taste.
One of the main reasons for the abysmal performance on the STK1000 was the lack of a floating point unit in the AP7000.
Libmodam used floating point numbers heavily.
The library was rewritten to use integer arithmetic, which helped immensely.
Further optimizations were iteratively applied after this, until the code reached a point of acceptable performance.

\subsection{The main program}

How everything was assembled in the main program.

\subsubsection{Setting up the LEDs}
\subsubsection{Setting up the buttons}

The button setup for this assignment is almost exactly the same as the setup from assignment 1.\cite{tdt4258-1}
The only difference is that the setup code is written in C, rather than assembly, which allows for higher lever abstractions.
The button code leverages the inversion of control principle, with dependency injection through the argument list of the setup function.

\subsubsection{Setting up the audio}

The audio setup code is organized in the same way as the LED and button setup code - an injectable setup function in a separate file.
The internal DAC, which is used for audio output, uses pin 20 and 21 of PIOB as output pins.
These pins must be disabled, because for some reason. What was it again?
The pins are instead given to peripheral A, which is the ABDAC.

In order to drive the ABDAC, a clock must be set up.
Generic clock 6 is the clock that powers the ABDAC.
The generic clock 6 is in the assignment set up to be driven by oscillator 1, which runs at 12Mhz.
Because the clock fires an ABDAC interrupt for every 256th clock tick, this means that the sample rate will be 46875.
This is a little high.
Luckily, the clock speed can be divided using the divide feature.
By enabling the divide feature, and setting the \texttt{div} to 0, the clock signal is divided by two.
This is because the clock speed is divided by $2\times($\texttt{div}$+1)$.


list of what we did:

* Board was set up w/ jumpers and such
* Leds and buttons were hooked up in hardware
* Leds and buttons were hooked up in software
* Code was split into separate files
* Audio was hooked up with apropriate settings
* Sound was tested to work using random noise


the following two groups of bullet points happened in parallel:

* a C sound effect synth inspired by sfxr was prototyped on a PC
* the synth was ported to avr32
* the synth was developed further on the avr32
* the synth was used in the stk1000 program to play various sound effects

* a C MOD player library + python tools inspired by amiga trackers were developed on a PC
* the library was tested on the avr32 and needed a great deal of optimization
* a great deal of optimization occurred 
* the library was used in the stk1000 program to play selected mods


finally:

* the actual main program flow was decided upon and written, hooking button and led behaviour together with sound effects and music
