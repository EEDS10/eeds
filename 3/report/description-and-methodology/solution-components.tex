This section describes the solutions' various components.

\subsection{Linux}
	The assignment required that the Linux 2.6 kernel be compiled for the AVR32 STK1000 development board.
	Specifically, Linux 2.6.16.11-avr32-20060626 was used.

	Linux was compiled and flashed onto a \texttt{16GB} SD Card, by virtue of following the distributed guidelines and a great deal of blood, sweat and tears\footnote{there were so many tears.}.

\subsection{Linux Device Drivers for the STK1000}
	Something about LDDs?
	Linux Device Drivers are pretty cool.
	They live in kernel space.
	Kernel space is like user space in the same way that the actions of children are like the actions of adults.


	Init and Exit functions and cleanup and such

	\subsubsection{Loading drivers}
	%insmod <driver>.ko
	%mknod /dev/leds c $(grep <driver> /proc/devices | awk '{print $1}') 0


	\subsubsection{LED driver}
		A custom driver was written for the STK1000 to facilitate the turning off and on of the LEDs.
		On initialization the driver obtains a major number dynamically and requests some region before enabling the relevant I/O pins by writing \texttt{0xFF} to the PIO Enable Register (\texttt{PER}) and to the Output Enable Register (\texttt{OER}).
		
		Upon exit, the driver turns the LEDs off by writing \texttt{0xFF} to the Clear Output Data Register (\texttt{CODR}) and \texttt{0x00} to the PIO Enable Register (\texttt{PER}) to disable the I/O pins.
		It also releases the region it requested during initialization.

		The driver interacts with the LEDs by first turning all the LEDs off (by writing \texttt{0xFF} to the \texttt{CODR}) and then enabling the desired LEDs by writing the given value to the Set Output Data Register (\texttt{SODR}).


		For a more detailed explanation of the set-up of the LEDs on the STK1000, see \cite{tdt4258-1}.
	\subsubsection{Button driver}
		A custom driver was written in order to allow the software to read the buttons' state.

		The button driver allows the video game to read the state of the buttons, letting them function as a source of input for the players.
		Its initialization is similar to the LED driver's, except that it writes \texttt{0xFF} to the Pull-up Enable Register (\texttt{PUER}) rather than the \texttt{OER}.
		Its exit function is similarly different.

		The driver reads the button's state by returning the value found in the Pin-Data Status Register (\texttt{PDSR}).


		For a more detailed explanation of the set-up of the buttons on the STK1000, see \cite{tdt4258-1}.	
	\subsubsection{Sound driver}
		/dev/dsp!
		OPEN SOUND SYSTEM -> http://en.wikipedia.org/wiki/Open_Sound_System
	\subsubsection{Display driver}
		The STK1000's has a screen.
		It has a resolution of \texttt{320}$\times$\texttt{240} and sports 32 bits per pixel (24 bit color depth, the last 8 bits are unused)\cite{lab-compendium}.
		However, only 24 of these are enabled by default\cite{avr32-disp}.

		Data is displayed on the screen by writing a bitmap buffer directly to \texttt{/dev/fb0}.

		% should we mention something about orientation?

        \subsection{EGE  - Eeds Game Engine}

    A simple state-based game engine was developed specifically for this assignment to ease the development of the solution game.
    The game engine features a simple state system which allows separation of different parts of the program.
    Each state can be thought of almost as a separate program, with separate functions for initializing, deiniting, updating and so on.
    In the solution game, separate states are used for the splash screen, the song selection menu, the actual gameplay part, and the score screen.

    The game engine also is responsible for timers, and makes sure that the game always runs at the same speed, independent of CPU load.
    This is done by enforcing separation of logical update code and rendering code.
    The idea is that while logical updating at a fixed rate is critical to maintaining temporal consistency in a game, rendering is not.
    Should the logical updating fall scheduling, rendering is delayed until the logical updating can catch up with real time again.
    Finally, the game only renders if the logical code has signalled that the screen needs a refresh since the last time it was redrawn. This is done to save time wasted on drawing the same image to the screen two times in a row.

    This description of the timers sucks a bit maybe. Maybe it should be clarified?


    The game engine also handles input and output through buttons and leds, providing convenient interfaces for hthe programmer to use.
    The buttons are regularly polled and their state is stored in a global array of boolean values.
    This allows the programmer to simply check the array to see if a button is pressed.
    Button presses can even be simulated programatically by writing to the keys array in between button polling.



    The leds are exposed through a single function set_leds, which allows the programmer to set the leds.


    Finally, the game engine also supports simple audio playing of raw audio data files.
    

	\subsubsection{Sound}
    The sound module of the game engine is capable of playing single raw audio files, as well as controlling the soundcard to set parameters such as bitrate and frequency.
    The game engine supports one audio file playing at a time, which can be set by loading and unloading an audio file to a global pointer.
    Mixing, compositing, and other advanced features are not implented.
	\subsubsection{Graphics}

    The graphics rendering module is bitmap-based, allowing for arbitrary regions of bitmaps to be blitted to and fro between bitmaps.


\subsection{``Fontenizer'': the Font Engine}
	A font rendering engine (\texttt{game/include/font.h} and \texttt{game/src/font.c}) was developed in order to easily render some given text on the screen.
	It does this by iterating through a given string\footnote{Actually a C string.} and locating each character's corresponding glyph in a given font bitmap.
	The glyphs are blitted one by one from the font bitmap to a destination bitmap one at a time.
    Variable horizontal character spacing is supported on a per-call basis, allowing for sophisticated kerning.
    Fontenizer supports the basic ASCII character set.
        
\subsection{The \texttt{.SM} file format}
	The \texttt{.SM} was created by the developers of StepMania. It is at the heart of every ``Song'' in StepMania as StepMania reads these files to obtain the location of the actual audio file as well as the steps.
	
	yo imma just rewrite http://www.stepmania.com/wiki/The_.SM_file_format
