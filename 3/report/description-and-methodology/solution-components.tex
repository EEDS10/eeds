This section describes the solutions' various components.

\subsection{Linux}
The assignment required that the Linux 2.6 kernel be compiled for the AVR32 STK1000 development board.
Specifically, Linux 2.6.16.11-avr32-20060626 was used.

Linux was compiled and flashed onto a \texttt{16GB} SD Card, by virtue of following the distributed guidelines and a great deal of blood, sweat and tears\footnote{there were so many tears.}.

\subsection{Linux Device Drivers for the STK1000}
In the game we use the buttons to interface with the user, as well as using the LEDs to help with the interface's affordance.
Both these actions require interfacing with the hardware of the STK1000, which is something we'd rather not be doing in the game's code base.

This is where a device driver comes in, it's job is to provide a more abstract interface to the hardware.
Loading device drivers are not straight forward, as they usually reside in kernel space.
Luckily, Linux makes it easy to dynamically load and remove drivers at will.

Many linux drivers, including the ones written for this assignment, allows other programs to interface with hardware through file-like devices.
The user may simply fopen a device, and then write and/or read data to it, with the driver as a middleware, translating the write and read calls to whatever is appropriate for the specific device.

\subsubsection{Loading drivers}
When you have a compiled kernel object (.ko) file, you may install it to the kernel with \texttt{insmod <driver>.ko}.
The drivers we use also require a file-like interface to the hardware, which is generated with \texttt{mknod /dev/<device name> c \$(grep <driver> /proc/devices | awk '\{print \$1\}') 0}.

Subsequently, if you want to remove the drivers to preserve memory, you can remove the module with \texttt{rmmod <driver>} and deleting the file with \texttt{rm /dev/<device name>}.

\subsubsection{LED driver}
A custom driver was written for the STK1000 to facilitate the turning off and on of the LEDs.
On initialization the driver obtains a major number dynamically and requests some region before enabling the relevant I/O pins by writing \texttt{0xFF} to the PIO Enable Register (\texttt{PER}) and to the Output Enable Register (\texttt{OER}).

Upon exit, the driver turns the LEDs off by writing \texttt{0xFF} to the Clear Output Data Register (\texttt{CODR}) and \texttt{0x00} to the PIO Enable Register (\texttt{PER}) to disable the I/O pins.
It also releases the region it requested during initialization.

The driver interacts with the LEDs by first turning all the LEDs off (by writing \texttt{0xFF} to the \texttt{CODR}) and then enabling the desired LEDs by writing the given value to the Set Output Data Register (\texttt{SODR}).


For a more detailed explanation of the set-up of the LEDs on the STK1000, see \cite{tdt4258-1}.
\subsubsection{Button driver}
A custom driver was written in order to allow the software to read the buttons' state.

The button driver allows the video game to read the state of the buttons, letting them function as a source of input for the players.
Its initialization is similar to the LED driver's, except that it writes \texttt{0xFF} to the Pull-up Enable Register (\texttt{PUER}) rather than the \texttt{OER}.
Its exit function is similarly different.

The driver reads the button's state by returning the value found in the Pin-Data Status Register (\texttt{PDSR}).


For a more detailed explanation of the set-up of the buttons on the STK1000, see \cite{tdt4258-1}.	
\subsubsection{Sound driver}
In order to produce sound, we use the provided ALSA\footnote{Advanced Linux Sound Architecture, see http://www.alsa-project.org/} driver.
This let us simply write raw sound data to \texttt{/dev/dsp} to play it, as described in \cite{lab-compendium}.

\subsubsection{Display driver}
The STK1000's has a screen.
It has a resolution of \texttt{320}$\times$\texttt{240} and sports 32 bits per pixel (24 bit color depth, the last 8 bits are unused)\cite{lab-compendium}.
However, only 24 of these are enabled by default\cite{avr32-disp}.

Data is displayed on the screen by writing a bitmap buffer directly to \texttt{/dev/fb0}.

% should we mention something about orientation?

        \subsection{EGE  - Eeds Game Engine}

    A simple state-based game engine was developed specifically for this assignment to ease the development of the solution game.
    The game engine features a simple state system which allows separation of different parts of the program.
    Each state can be thought of almost as a separate program, with separate functions for initializing, deiniting, updating and so on.
    In the solution game, separate states are used for the splash screen, the song selection menu, the actual gameplay part, and the score screen.

    The game engine also is responsible for timers, and makes sure that the game always runs at the same speed, independent of CPU load.
    This is done by enforcing separation of logical update code and rendering code.
    The idea is that while logical updating at a fixed rate is critical to maintaining temporal consistency in a game, rendering is not.
    Should the logical updating fall scheduling, rendering is delayed until the logical updating can catch up with real time again.
    Finally, the game only renders if the logical code has signalled that the screen needs a refresh since the last time it was redrawn. This is done to save time wasted on drawing the same image to the screen two times in a row.

    %TODO
    This description of the timers sucks a bit maybe. Maybe it should be clarified?


    The game engine also handles input and output through buttons and leds, providing convenient interfaces for hthe programmer to use.
    The buttons are regularly polled and their state is stored in a global array of boolean values.
    This allows the programmer to simply check the array to see if a button is pressed.
    Button presses can even be simulated programatically by writing to the keys array in between button polling.



    The leds are exposed through a single function set_leds, which allows the programmer to set the leds.


    Finally, the game engine also supports simple audio playing of raw audio data files.


\subsubsection{Sound}
The sound module of the game engine is capable of playing single raw audio files, as well as controlling the soundcard to set parameters such as bitrate and frequency.
The game engine supports one audio file playing at a time, which can be set by loading and unloading an audio file to a global pointer.
Mixing, compositing, and other advanced features are not implented.

\subsubsection{Graphics}
The graphics rendering module is entirely based on bitmaps.
In order to generate the graphics to display to the user, various bitmaps are blitted in order to achieve the desired visual components and effects.


\subsection{``Fontenizer'': the Font Engine}
	A font rendering engine (\texttt{game/include/font.h} and \texttt{game/src/font.c}) was developed in order to easily render some given text on the screen.
	It does this by iterating through a given string\footnote{Actually a C string.} and locating each character's corresponding glyph in a given font bitmap.
	The glyphs are blitted one by one from the font bitmap to a destination bitmap one at a time.
    Variable horizontal character spacing is supported on a per-call basis, allowing for sophisticated kerning.
    Fontenizer supports the basic ASCII character set.
        
\subsection{The \texttt{.SM} file format}
The \texttt{.SM}\footnote{http://www.stepmania.com/wiki/The_.SM_file_format} was created by the developers of StepMania.
The .SM-files contain meta-data of every song such as artist and title, as well as the name of the sound file and which buttons you are supposed to press when.
