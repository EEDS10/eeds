
\subsection{Setup and compilation of Linux}

Linux was installed to an 512MB SD card following the instructions from oeving3\_guidelines.txt from itslearning CITE. 
The SD card was formatted to \texttt{ext2} using\texttt{gparted} on \texttt{Xubuntu 12.10} runnning on a Sony Vaio Z, as the recommended procedure using \texttt{cfdisk} on the lab machines did not work.
An attempt was made at compiling the linux kernel, but as critical dependencies were missing, a pre-prepared disk image was used instead. The SD card was flashed with this disk image using \texttt{dd}.
Next, the u-boot bootloader from the supplied materials for the assignment was flashed to the \texttt{STK1000} using the \texttt{JTAGICE}, and a \texttt{minicom} connection was set up to the board using a serial cable connected to \texttt{UART\_A}.

\texttt{Minicom} does not work together with the supplied linux materials out-of-the-box, and a number of settings must be changed in order for the setup to work.


First, \texttt{minicom}'s hardware flow control must be switched off in the \texttt{minicom} settings.
Second, \texttt{U-Boot} needs some \texttt{STK1000}/linux-specific options set in order to be able to boot linux.


Here are the commands needed, presented as a convenient and easy-to-read one-liner in figure \ref{fig-ubootcommand}.


\begin{figure}
\texttt{setenv bootcmd 'mmc init; ext2load mmc 0:1 0x90400000 /boot/uImage; fsload; bootm \$(fileaddr)'; setenv bootargs 'console=ttyS0 root=/dev/mmcblk0p1 fbmem=600k rootwait'; saveenv; boot}
\label{fig-ubootcommand}
\caption{A convenient and easy-to-read one-liner.}
\end{figure}


Breaking this command down into its subparts, it is easier to see what it does.


\texttt{setenv bootcmd ...} 
This sets the command that are automatically run on boot.

\texttt{mmc init} 
This initializes the memory card controller on the development board.

\texttt{ext2load mmc 0:1 0x90400000 /boot/uImage} 
Loads a ext2 filesystem from the sdcard and sets an entrypoint/location of linux' boot image.

\texttt{fsload} 
Loads a filesystem.

\texttt{bootm \$(fileaddr)} 
Boots the linux boot image.

\texttt{setenv bootargs ...} 
Sets the arguments that are passed when boot is called.

\texttt{console=ttyS0} 
Sselects which console to connect to.

\texttt{root=/dev/mmcbkl0p1} 
Sets the location of the file system root.

\texttt{rootwait} 
This commands waits for the root address to become available, effectively allowing the mmc to warm up properly before proceeding.

\texttt{saveenv} 
This saves the current environment variables to the flash memory of the stk1000, so that these commands only have to be entered once.

\texttt{boot} 
Finally, this command tells uboot to boot!



\subsection{Drivers}

The drivers were developed on the lab machines, cross-compiled to AVR32 using \texttt{avr32-linux-gcc} and \texttt{scp}'d to the \texttt{STK1000} for testing.
First, a helloworld-driver was developed.
Then, an LED driver was developed.
Finally, a button driver was developed.

A script for inserting modules and making device nodes using information from \texttt{/proc/devices} was written, and is part of the solution suite.


\subsection{Eeds Game Engine}

The game engine was developed to enable cross-platform development of games, using different polyfills and libraries for different platforms. The game engine was developed in parallel with the development of Scorched Land Dance Dance Defence, because agile.

\subsection{Scorched Land Dance Dance Defence}

Scorched Land Dance Dance Defence was primarily developed on x86 developer's laptops running linux, using Eeds Game Engine's allegro bindings to be able to interface with IO such as screen and keyboard.
This was done in part because it allows for use of the rich amount of great development tools available on a modern developer laptop, including tools such as \texttt{gdb}, \texttt{valgrind}, and more.
Additionally, this approach meant that development could happen in other physical locations than in the lab.
The productivity boost gained from this architecture and development approach was quite enabling.

Scorched Land Dance Dance Defence was developed more or less in decoupled parallel, as each state in the game engine is able to more or less stand on its own.
A diverse toolset of self-authored scripts were used for smoothalizing the development process when interfacing with the STK1000.
One of these tools is a startup script on the STK1000 which 'calls home' to a 3rd party server to tell it about its new IP address.
Developers may then programatically connect to the STK1000 over the internet without having to lookup the IP-address on the STK1000 manually using minicom or other tools, as they can simply query the third party server.
A lot of work was put into making the development experience as frictionless as possible.


% digression about test resulting in us dropping 2-player mode
TODO: this digression should probably be moved somehwhere else?
We did some prototype testing and came to the conclusion that having two players control each trying to use four buttons on the board simultaneously did not result in an enjoyable experience.
Our testers preferred being the sole user of the STK1000's buttons.
A possible explanation for this is that all of our testers were above the age of 20 and did not posess the child-like hand size required to operate four neighbouring STK1000 buttons at the same time.

and implemented transparency

then we played dat music

and got the steps to synch up to it

\subsection{Features left unimplemented}
	here are some features we did not have time to implement


	preview of the selected song in the main menu

	other step types (doubles, mines, holds)
		Note: SLDDD treats each individual arrow as a step. 

	multithreading
		the entire vidya is single threaded, meaning the playback of music runs in the same thread as the rest of the game. Because threading is for pussies.

	automatic adjustment of note scroll speed
		we have to add songs manually and tailor the notes' scroll speed
		this is the opposite of agile cloud :(

	life bar
