
\subsection{Setup and compilation of Linux}

Linux was installed to an 512MB SD card following the instructions from oeving3\_guidelines.txt from itslearning CITE. 
The SD card was formatted to \texttt{ext2} using\texttt{gparted} on \texttt{Xubuntu 12.10} runnning on a Sony Vaio Z, as the recommended procedure using \texttt{cfdisk} on the lab machines did not work.
An attempt was made at compiling the linux kernel, but as critical dependencies were missing, a pre-prepared disk image was used instead. The SD card was flashed with this disk image using \texttt{dd}.
Next, the u-boot bootloader from the supplied materials for the assignment was flashed to the \texttt{STK1000} using the \texttt{JTAGICE}, and a \texttt{minicom} connection was set up to the board using a serial cable connected to \texttt{UART\_A}.

\texttt{Minicom} does not work together with the supplied linux materials out-of-the-box, and a number of settings must be changed in order for the setup to work.


First, \texttt{minicom}'s hardware flow control must be switched off in the \texttt{minicom} settings.
Second, \texttt{U-Boot} needs some \texttt{STK1000}/linux-specific options set in order to be able to boot linux.


Here are the commands needed, presented as a convenient and easy-to-read one-liner in figure \ref{fig-ubootcommand}.


\begin{figure}
\texttt{setenv bootcmd 'mmc init; ext2load mmc 0:1 0x90400000 /boot/uImage; fsload; bootm \$(fileaddr)'; setenv bootargs 'console=ttyS0 root=/dev/mmcblk0p1 fbmem=600k rootwait'; saveenv; boot}
\label{fig-ubootcommand}
\caption{A convenient and easy-to-read one-liner.}
\end{figure}


Breaking this command down into its subparts, it is easier to see what it does.


\texttt{setenv bootcmd ...} 
This sets the command that are automatically run on boot.

\texttt{mmc init} 
This initializes the memory card controller on the development board.

\texttt{ext2load mmc 0:1 0x90400000 /boot/uImage} 
Loads a ext2 filesystem from the sdcard and sets an entrypoint/location of linux' boot image.

\texttt{fsload} 
Loads a filesystem.

\texttt{bootm \$(fileaddr)} 
Boots the linux boot image.

\texttt{setenv bootargs ...} 
Sets the arguments that are passed when boot is called.

\texttt{console=ttyS0} 
Sselects which console to connect to.

\texttt{root=/dev/mmcbkl0p1} 
Sets the location of the file system root.

\texttt{rootwait} 
This commands waits for the root address to become available, effectively allowing the mmc to warm up properly before proceeding.

\texttt{saveenv} 
This saves the current environment variables to the flash memory of the stk1000, so that these commands only have to be entered once.

\texttt{boot} 
Finally, this command tells uboot to boot!



\subsection{Drivers}

The drivers were developed on the lab machines, cross-compiled to AVR32 using \texttt{avr32-linux-gcc} and \texttt{scp}'d to the \texttt{STK1000} for testing.
First, a helloworld-driver was developed.
Then, an LED driver was developed.
Finally, a button driver was developed.

A script for inserting modules and making device nodes using information from \texttt{/proc/devices} was written, and is part of the solution suite.


\subsection{Eeds Game Engine}

The game engine was developed to enable cross-platform development of games, using different polyfills and libraries for different platforms. The game engine was developed in parallel with the development of Scorched Land Dance Dance Defence, because agile.

\subsection{Scorched Land Dance Dance Defence}

Scorched Land Dance Dance Defence was primarily developed on x86 developer's laptops running linux, using Eeds Game Engine's allegro bindings to be able to interface with IO such as screen and keyboard.
This was done in part because it allows for use of the rich amount of great development tools available on a modern developer laptop, including tools such as \texttt{gdb}, \texttt{valgrind}, and more.
Additionally, this approach meant that development could happen in other physical locations than in the lab.
The productivity boost gained from this architecture and development approach was quite enabling.

Scorched Land Dance Dance Defence was developed more or less in decoupled parallel, as each state in the game engine is able to more or less stand on its own.
A diverse toolset of self-authored scripts were used for smoothalizing the development process when interfacing with the STK1000.
One of these tools is a startup script on the STK1000 which 'calls home' to a 3rd party server to tell it about its new IP address.
Developers may then programatically connect to the STK1000 over the internet without having to lookup the IP-address on the STK1000 manually using minicom or other tools, as they can simply query the third party server.
A lot of work was put into making the development experience as frictionless as possible.



and implemented transparency

then we played dat music

and got the steps to synch up to it


\subsection{Features left unimplemented}
	here are some features we did not have time to implement


	preview of the selected song in the main menu

	other step types (doubles, mines, holds)
		Note: SLDDD treats each individual arrow as a step. 

	multithreading
		the entire vidya is single threaded, meaning the playback of music runs in the same thread as the rest of the game. Because threading is for pussies.

	automatic adjustment of note scroll speed
		we have to add songs manually and tailor the notes' scroll speed
		this is the opposite of agile cloud :(

	life bar


\subsection{Tools}

Because manual work is boring and automation is awesome, several tools and scripts were developed to make life easier.

connect.sh
This is a script which automatically opens an SSH-connection to the STK1000, without prompting for a password. It can detect when the IP-address of the board has changed, and can find the new address automatically using a thrid party server as a connection broker.

flashnboot.sh
This is a script which flashes U-Boot to an STK1000, configures it to boot correctly from an SD-card with the supplied linux SD-image, and then boots the board.
Its primary use is to set up a new board for linux development.

load\_drivers.sh
This is a script which automatically loads the drivers and makes the device nodes for the LEDs and buttons on the STK1000.

fix\_sound.sh
This is a script which automatically unmutes the STK1000.

The call-home-script
This is a script which pings a third party connection broker web server at boot time to let the world know at which IP-address it can be reached.

Makefiles
The Makefiles for the drivers and for the game were set up to automatically cross-compile and upload the code from the lab-PCs to the STK1000, and optionally run them as well, without prompting for any user input such as passwords or similar things.

