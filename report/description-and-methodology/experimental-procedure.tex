The first thing we did was locate the lab, on the fourth floor of the IT-Vest building at NTNU, room 458. 
We removed one of the AVR32STK1000 boards from their box and set the jumpers to the appropriate positions (\cite{lab-compendium}, pg 37).
We booted up one of the computers and connected the AVR32STK1000 to it. 
Our first piece of code simply enabled all the LEDs and turned them on. Once we got the LEDs working we enabled the buttons.
We followed this up by writing code to turn on just one of the LEDs, designated the ''paddle'' per the assignment's description (\cite{lab-compendium}, pg 37).
Shortly thereafter we gave up on trying to figure out GDB, as the GDB setup instructions in the supplied resources [which?] were erroneous.
Code was written to move right when \texttt{SW0} is pushed, and left when\texttt{SW2} is pushed, employing arithmetic shift to move the paddle bit in the appropriate direction.
However, a single push of either button caused the paddle to disappear, due to a combination of us simply letting the paddle's bit overflow when it reached either edge and the fact that a button press was registered for each  iteration of the program's main loop was completed while a button was pressed.
We altered our code so that the paddle would ''loop around'' to the opposite side of the row of LEDs when it was ''pushed off'' either side.
At this point, when pushing either buttons, all the LEDs would light up briefly in turn at such high a speed that it looked like they were all dimly lit simultaneously.
This is again because of the massive amount of times the main loop could iterate whilst a button is pressed, causing the paddle to cycle the LED row at break-neck speeds.
Implementing some sort of button cool-down to reduce the frequency of registered button presses would be the next step if we wanted to continue working with the polling approach to button handling, but we opted rather to migrate to an interrupt-based approach, as this offers the same advantages.
Implementing interrupts for the buttons introduced bouncing problems, which we solved by implementing software debouncing (\cite{lab-compendium}, Fig. 2.9a).

We had an issue where the paddle would move over one additional LED when a button was pushed (i.e. from \texttt{LEDn} to \texttt{LEDn+2} rather than from \texttt{LEDn} to \texttt{LEDn+1}).
This was caused by the fact that lifting a button from a pressed state to an unpressed state generated an unwanted interrupt.
This was fixed by, in effect, ignoring every second registered push of each button.
Finally we measured the current on the board's various pins while an interrupt-based program was running, and again with a busy-waiting program in order to compare the energy efficiency of the two solutions.
